"""
app/models/schemas.py

Pydantic models (schemas) for API request/response validation.

IMPORTANT: These are NOT SQLAlchemy ORM models.
  - ORM models  → define database tables  (Person 3's responsibility)
  - These schemas → define the JSON shapes the API accepts and returns

How Pydantic works here:
  - FastAPI automatically validates incoming JSON against these models.
  - If the incoming data is missing a required field or has the wrong type,
    FastAPI returns a 422 Unprocessable Entity error automatically.
  - Field(...) means the field is REQUIRED (no default value).
  - Field(default=...) means the field is OPTIONAL with a fallback.

Module layout:
  ComponentSchema     – a node in the architecture graph
  DataFlowSchema      – a directed edge between two components
  ArchitectureSchema  – the full graph (nodes + edges together)

Output Schema
  CriticalityRankEntry   – one row in the criticality table
  SimulationResultSchema – complete result of running a scenario 
  HealthResponse         – shape of GET /health
  ErrorResponse          – shape of error responses
  
"""

from typing import Any, Optional

# BaseModel  : base class for all Pydantic models
# Field      : used to attach metadata (description, constraints, defaults)
from pydantic import BaseModel, Field


# INPUT SCHEMAS  (data flowing INTO the simulator)


class ComponentSchema(BaseModel):
    """
    A single node in the mission architecture graph.

    In the React Flow diagram editor (frontend), each draggable block on the
    canvas corresponds to one ComponentSchema.  When the user saves the
    architecture, the frontend sends a list of these objects to the backend.

    Maps to the `components` table in PostgreSQL (Person 3's ORM model),
    but this schema is what travels over the wire as JSON.

    Component types recognised by the simulator:
        Sensor      – collects environmental or signal data
        Compute     – processes data (servers, edge nodes, etc.)
        CommsLink   – transmits data between other components
        Control     – issues commands based on processed data
        Storage     – persists data (databases, file stores)
        External    – third-party or off-system dependency
    """

    # Unique identifier – generated by the frontend (e.g. uuid4 or a slug).
    # The simulator uses this as the NetworkX node key, so it must be unique
    # within a single architecture.
    id: str = Field(..., description="Unique component identifier (UUID or slug)")

    # Display name shown on the diagram canvas and in result tables.
    name: str = Field(..., description="Human-readable component name")

    # Component category – drives how the simulator interprets the node.
    # Future increments may add type-specific propagation rules (e.g. a
    # CommsLink failure behaves differently from a Sensor compromise).
    type: str = Field(
        ...,
        description="Component category",
        examples=["Sensor", "Compute", "CommsLink", "Control", "Storage", "External"],
    )

    # User-assigned importance score on a 1–10 scale.
    #   1  = low priority (losing it barely affects the mission)
    #   10 = mission-critical (losing it immediately degrades mission success)
    # The simulator combines this with the graph in-degree to produce a
    # composite criticality score in rank_criticality().
    criticality: int = Field(
        default=5,           # Default to mid-range so new nodes aren't invisible
        ge=1,                # ge = "greater than or equal to" → minimum value 1
        le=10,               # le = "less than or equal to"   → maximum value 10
        description="User-assigned criticality (1=low, 10=critical)",
    )

    # (x, y) pixel coordinates on the React Flow canvas.
    # The backend stores these so the diagram layout is preserved on reload.
    # Not used by the simulator engine itself.
    position: dict[str, float] = Field(
        default_factory=lambda: {"x": 0.0, "y": 0.0},  # Origin by default
        description="Canvas position for the diagram editor",
    )


class DataFlowSchema(BaseModel):
    """
    A directed edge (data flow) between two components.

    In the React Flow diagram, each arrow drawn from one component to another
    becomes one DataFlowSchema.  The direction matters: data flows FROM
    `source` TO `target`, which determines how attacks propagate.

    Example: Sensor → Compute → Control
      If the Sensor is compromised, bad data flows downstream to Compute,
      which then feeds incorrect inputs to Control.

    CIA properties (cia_requirement) let the simulator apply more nuanced
    propagation rules in Increment 2:
      - confidentiality: data must not be disclosed to unauthorised parties
      - integrity:       data must not be tampered with in transit
      - availability:    data must be continuously accessible
    """

    # Unique identifier for this flow – used for database storage and debugging.
    id: str = Field(..., description="Unique flow identifier")

    # The component ID where data originates.
    # Must match an `id` in the parent ArchitectureSchema.components list.
    source: str = Field(..., description="Source component ID")

    # The component ID where data is delivered.
    # Must match an `id` in the parent ArchitectureSchema.components list.
    target: str = Field(..., description="Target component ID")

    # What kind of data travels over this link (e.g. "telemetry", "commands").
    # Optional metadata – not currently used by the simulator but stored for
    # future use and display in the results panel.
    data_type: Optional[str] = Field(None, description="Type of data transmitted")

    # Which CIA property this flow depends on.
    # Increment 2 will use this to route compromise differently:
    #   integrity loss   → spreads to components that depend on correct data
    #   availability loss→ spreads to components needing continuous connection
    #   confidentiality  → spreads to components handling sensitive data
    cia_requirement: Optional[str] = Field(
        None,
        description="CIA property required: confidentiality | integrity | availability",
    )

    # How time-sensitive this data link is.
    # Future work: high-latency attacks could disproportionately affect
    # high-sensitivity flows.
    latency_sensitivity: Optional[str] = Field(
        None,
        description="Latency sensitivity: low | medium | high",
    )


class ArchitectureSchema(BaseModel):
    """
    The complete mission architecture – the full graph definition.

    This is the top-level object that the frontend sends to the backend when
    saving an architecture, and what the backend reconstructs from the database
    when running a simulation.

    Relationship to the database (Person 3):
      - One row in the `architectures` table  →  one ArchitectureSchema
      - Each ComponentSchema                  →  one row in `components`
      - Each DataFlowSchema                   →  one row in `data_flows`

    The simulator (MissionArchitectureSimulator) accepts this object directly
    and converts it into a NetworkX DiGraph internally.
    """

    # None when creating a new architecture (not yet saved to DB).
    # Populated by the database after a successful INSERT.
    id: Optional[int] = Field(None, description="Database-assigned ID (None for new)")

    # Short label for the architecture – shown in the load dropdown.
    name: str = Field(..., description="Architecture name")

    # Optional longer description stored alongside the architecture.
    description: Optional[str] = Field(None, description="Optional description")

    # All components (nodes) in this architecture.
    # An empty list is valid for a new, unsaved architecture.
    components: list[ComponentSchema] = Field(default_factory=list)

    # All data flows (directed edges) between components.
    # The simulator validates that every source/target ID exists in components.
    flows: list[DataFlowSchema] = Field(default_factory=list)



# OUTPUT SCHEMAS  (data flowing OUT of the simulator)


class CriticalityRankEntry(BaseModel):
    """
    One row in the component criticality ranking table.

    The simulator produces a ranked list of these after every simulation run.
    The frontend displays them in a table so mission planners can immediately
    see which components to prioritise for hardening.

    Criticality score formula (see simulator.rank_criticality()):
        score = user_criticality + graph_in_degree

    Where:
        user_criticality – the 1-10 value set by the mission planner
        graph_in_degree  – number of other components that feed INTO this one
                           (higher in-degree = more dependencies rely on it)

    Tie-breaking:
        When two components share the same composite score, the one with more
        descendants (downstream dependents) ranks higher.
    """

    # The component's unique ID – matches ComponentSchema.id
    component_id: str

    # Human-readable name for display in the results table
    component_name: str

    # Component category (Sensor, Compute, etc.) for the results table
    component_type: str

    # Composite criticality score: higher = more important to protect
    criticality_score: float = Field(
        description="Combined score: user criticality + graph in-degree"
    )

    # True if this component was in the affected set during the simulation.
    # Lets the frontend highlight compromised rows in red.
    affected: bool = Field(description="Whether this component was affected by the attack")


class SimulationResultSchema(BaseModel):
    """
    The complete result of running one attack scenario.

    Returned by POST /architectures/{id}/simulate.

    The frontend uses this object to populate:
      - The bar chart (baseline_score vs compromised_score)
      - The "What Happened" text panel (explanation + attack_path)
      - The affected components table (affected_components / affected_component_names)
      - The criticality ranking table (criticality_ranking)

    Score interpretation:
        100.0 → all components healthy, mission fully capable
          0.0 → all components compromised, mission failed
        e.g. 66.7 → 2 of 3 components healthy (one compromised)
    """

    # Which architecture was simulated – echoed back so the frontend can
    # verify the response matches the request.
    architecture_id: int

    # Which attack scenario was run, e.g. "node_compromise".
    # Echoed back so the frontend can display the scenario name.
    scenario_type: str

    # The component that was directly attacked.
    # Echoed back so the frontend can highlight it on the diagram.
    target_component_id: str

    # Mission success score BEFORE the attack (always 100.0 in Increment 1
    # because no pre-existing degradation is modelled yet).
    # ge=0.0, le=100.0 → Pydantic enforces the 0–100 range at serialisation time.
    baseline_score: float = Field(
        ge=0.0, le=100.0, description="Score before attack (%)"
    )

    # Mission success score AFTER the attack.
    # Formula: (healthy_components / total_components) * 100
    compromised_score: float = Field(
        ge=0.0, le=100.0, description="Score after attack (%)"
    )

    # compromised_score - baseline_score.
    # Negative value means the attack degraded the mission (expected).
    # e.g. -40.0 means the mission lost 40 percentage points of capability.
    score_delta: float = Field(
        description="Percentage-point drop (negative = degraded)"
    )

    # List of component IDs that were compromised (the target + its descendants).
    # Used by the frontend to colour compromised nodes red on the diagram.
    affected_components: list[str] = Field(
        description="IDs of affected components"
    )

    # Parallel list of human-readable names matching affected_components.
    # Avoids requiring the frontend to do its own ID→name lookup.
    affected_component_names: list[str] = Field(
        description="Names of affected components"
    )

    # Ordered list of strings describing how the compromise spread, e.g.:
    #   ["Step 1: Sensor 'Sensor-1' directly compromised (integrity loss)",
    #    "Step 2: Compute 'Compute-1' receives corrupted data from 'Sensor-1'",
    #    "Step 3: Mission objective degraded due to 2 compromised components"]
    # Generated by BFS traversal from the target node.
    attack_path: list[str] = Field(
        description="Step-by-step propagation narrative"
    )

    # A single sentence summarising the attack outcome for the results panel.
    # e.g. "Node compromise on 'Sensor-1'. Compromise propagated to 2 downstream
    #        component(s). Mission success score degraded from 100.0% to 33.3%."
    explanation: str = Field(description="Human-readable summary")

    # Top components ranked by composite criticality score.
    # Lets the planner immediately see which components to harden first.
    criticality_ranking: list[CriticalityRankEntry] = Field(
        description="Top components by criticality"
    )


class HealthResponse(BaseModel):
    """
    Response shape for GET /health.

    Used by:
      - GitHub Actions CI – verifies the backend started successfully
      - Render health checks – determines whether to route traffic to the pod
      - Local development – quick sanity check that the server is up

    Example response body:
        {"status": "healthy", "environment": "development"}
    """

    # Always "healthy" when the endpoint responds (if the app is broken,
    # the request never reaches this handler).
    status: str

    # The ENVIRONMENT variable from .env: "development" | "staging" | "production"
    # Lets the frontend or ops team confirm which environment they're hitting.
    environment: str


class ErrorResponse(BaseModel):
    """
    Standard error response shape for non-2xx responses.

    FastAPI generates its own 422 validation errors automatically, but for
    application-level errors (404, 500, custom SimulatorError), we return
    this shape so the frontend always receives a consistent error object.

    Example 422 response body:
        {
            "detail": "Component 'sensor-99' not found in the architecture.",
            "error_code": "COMPONENT_NOT_FOUND",
            "extra": {"component_id": "sensor-99"}
        }
    """

    # Human-readable error message – safe to display in the UI.
    detail: str

    # Optional machine-readable error code for the frontend to branch on.
    # e.g. "COMPONENT_NOT_FOUND", "UNKNOWN_SCENARIO", "ARCHITECTURE_NOT_FOUND"
    error_code: Optional[str] = None

    # Optional bag of additional context (IDs, values) to help debugging.
    # The `Any` type allows arbitrary nested data.
    extra: Optional[dict[str, Any]] = None
